- [자료구조와 알고리즘](#자료구조와-알고리즘)
- [시간복잡도와 공간복잡도](#시간복잡도와-공간복잡도)
- [배열](#배열)
- [연결 리스트](#연결-리스트)
- [스택](#스택)
- [큐](#큐)
- [해시 테이블](#해시-테이블)
- [트리](#트리)
- [그래프](#그래프)

### 자료구조와 알고리즘

- 자료구조 : 데이터를 효율적으로 관리할 수 있는 데이터의 구조 및 연산 방법
- 알고리즘 : 어떠한 목적을 이루기 위해 필요한 일련의 연산 절차

데이터가 어떻게 저장되고 구성되어 있는지에 따라 알고리즘의 성능 및 복잡도가 결정된다.

### 시간복잡도와 공간복잡도

시간복잡도와 공간복잡도는 소스 코드가 얼마나 효율적인지 판단하는 척도이다.

- 시간 복잡도 : 입력의 크기에 따른 프로그램 실행 시간의 관계
  - 입력에 다른 실행 시간의 점근적 상한을 의미하는 <b>빅오 표기법(O)<b>을 통해 나타낸다.
  - 점근적 상한이란 입력값 n이 증가함에 있어서 실행 시간이 증가하는 한계를 의미한다.
    - <b>O(n)</b>이란 n이 무한대로 커진다고 하더라도 실행시간의 증가율이 n보다 작다는 것을 의미한다.
  - 입력에 대한 평균적인 실행 시간을 나타내는 빅 세타 표기법(Θ), 실행시간의 점근적 하한을 의미하는 빅 오메가 표기법(Ω) 등이 있다.
  - 빅오 표기법에서는 최고차항의 차수만 고려하면 된다.
  - O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(2ⁿ) < O(n!)
- 공간복잡도 : 프로그램이 실행되었을 때 필요한 메모리 자원의 양

### 배열

- 일정한 메모리 공간에 차지한 여러 요소들이 순차적으로 나열된 자료구조 ⇒ 관련있는 데이터를 일렬로 나열하여 관리할 때 용이하다.
- 인덱스를 통해 요소에 일정한 접근 시간으로 인덱싱 ⇒ O(1)
- 특정 요소 삽입, 삭제, 앞에서부터 차례대로 조회 ⇒ O(n)
- 프로그램 실행 전 배열의 크기가 고정되어 있는 정적 배열, 동적으로 배열의 크기가 변하는 동적 배열로 구분한다.

### 연결 리스트

- 연결리스트의 구성 단위인 노드의 모음으로 구성된 자료구조
  - 노드는 저장하고자 하는 <b>데이터 + 다음 노드의 위치 정보(메모리 상의 주소)</b>로 구성
  - 연속적으로 구성되어 있는 데이터를 불연속적으로 저장할 때 유용하다.
- 첫 번째 노드(헤드, Head), 마지막 노드(꼬리, Tail)
- 앞에서 부터 특정 요소 순차적 접근 ⇒ O(n)
- 삽입 또는 삭제할 노드의 위치가 주어졌으 때 삽입, 삭제 ⇒ O(1)
- 이중 연결 리스트(이전, 다음 노드의 위치 정보 저장), 원형 연결 리스트(꼬리 노드가 헤드 노드를 가리킴)

### 스택

- 한쪽에서 데이터의 삽입 및 삭제가 가능한 자료구조
- 후입선출(LIFO) 자료구조
  - 데이터 저장(PUSH), 데이터 삭제(POP)
- 최근에 임시 저장한 데이터를 가장 먼저 활용해야하는 경우(ex. 함수의 매개변수 저장), 뒤로가기 기능 등에 활용된다.

### 큐

- 한 쪽으로 데이터를 삽입하고, 다른 한 쪽으로 데이터를 삭제할 수 있는 자료구조
- 선입 선출(FIFO) 자료구조
  - 데이터 저장(Enqueue), 데이터 삭제(Dequeue)
- 저장된 데이터를 차례로 꺼내오는 버퍼(Buffer)로 활용
- 여러 형태로 변형된 큐
  - 원형 큐 : 데이터를 삽입하는 쪽과 삭제하는 쪽을 연결해 원형으로 사용
  - 덱(deque) : 양쪽으로 데이터 삽입/삭제가 가능한 큐
  - 우선순위 큐 : 요소들이 선입선출이 아닌 우선순위가 높은 순으로 처리되는 큐

### 해시 테이블

- 키와 값의 대응으로 이루어진 표와 같은 형태의 자료구조
  - 키는 해시 테이블에 대한 입력, 값은 키를 통해 얻고자 하는 데이터
- 해시테이블 구조와 동작
  - 키를 통해 얻고자 하는 데이터는 버킷에 저장되며 여러 버킷들은 배열을 형성한다.
  - 해시 함수는 킬을 인자로 활용해 인덱스를 반환하고, 해당 인덱스가 버킷 배열의 인덱스가 된다.
- 해시 함수
  - 임의의 길이의 데이터가 고정된 길이의 데어터로 변환하는 단방향 함수
  - 해시 알고리즘은 해시 함수의 연산 방법
  - 데이터의 무결성을 검증하기 위한 수단으로 사용된다.
- 해시 테이블을 사용하는 이유
  - 일반적인 상황에서 검색, 삽입, 삭제 연산의 시간 복잡도는 O(1)로 입력과는 무관하게 빠른 검색 속도를 보장한다.
- 해시 테이블의 단점
  - 데이터가 많을 경우 상대적으로 많은 메모리 공간이 소모된다.
  - 해시 충돌이 발생한다.
- 해시 충돌
  - 서로 다른 키에 대해 값은 해시 값이 대응되는 상황
- 해시 충돌 해결책
  - 체이닝 : 충돌이 발생한 데이터를 연결 리스트로 추가하는 방법.
    - 해시 테이블의 장점인 빠른 검색 속도라는 장점이 없어질 수 있다.
  - 개방 주소법 : 충돌이 발생한 버킷의 인덱스가 아닌 다른 인덱스에 데이터를 저장하는 방법
    - 조사(Probe) : 충돌이 발생했을 때 비어 있는 다른 버킷의 인덱스를 찾는 과정
    - 선형 조사법 : 충돌이 발생한 인덱스의 다음 인덱스부터 순차적으로 가용한 인덱스를 찾는 방법 ⇒ 해시 충돌이 발생한 인덱스 인근에 충돌이 발생한 여러 데이터가 몰려 저장되는 군집화 현상이 발생할 가능성이 있다. ⇒ 순차 탬색으로 인한 성능 악화
  - 이중 해싱 : 2개의 해시 함수를 사용하는 방법

### 트리

- 계층적 구조를 표현하기 위한 자료구조
- 트리 관련 용어
  - 노드 : 데이터를 저장하는 요소
  - 간선(링크) : 노드와 노드를 연결하는 요소
  - 부모 노드 : 어떤 노드의 상위에 연결된 노드
  - 자식 노드 : 어떤 노드의 하위에 연결된 노드
  - 루트 노드 : 트리의 최상위 노드. 부모 노드 X
  - 리프 노드 : 트리의 최하위 노드. 자식 노드 X
  - 차수 : 노드의 자식 노드의 수
  - 레벨 : 루트 노드에서 시작해 특정 노드에 이르기까지 거치게 되는 간선의 수
  - 서브트리 : 트리에 포함되어 있는 부분 트리
- 데이터와 자식 노드의 위치 정보를 저장하는 방식으로 트리를 구현할 수 있다.
- 트리의 순회
  - 전위 순회 : 루트 노드 ⇒ 왼쪽 서브트리 전위 ⇒ 오른쪽 서브트리 준위
  - 중위 순회 : 왼쪽 서브트리 중위 ⇒ 루트 ⇒ 오른쪽 서브트리 중위
  - 후위 순회 : 왼쪽 서브트리 후위 ⇒ 오른쪽 서브트리 후위 ⇒ 루트
- 이진트리(자식 노드의 개수가 2개 이하인 트리)의 종류
  - 정 이진트리(Full Binary Tree) : 자식 노드의 개수가 1개가 아닌 이진 트리
  - 포화 이진트리(Perfect Binary Tree) : 리프노드를 제외한 모든 노드들이 자식 노드를 2개씩 가지고 있고, 모든 리프 노드의 레벨이 동일한 이진 트리
  - 완전 이진트리(Complete Binary Tree) : 마지막 레벨을 제외한 모든 레벨이 2개의 자식 노드를 가지고 있고, 마지막 레벨의 모든 노드들이 왼쪽부터 존재하는 이진 트리
  - 이진 탐색 트리(Binary Search Tree, BST) : 특정 노드의 왼쪽에는 해당 노드보다 작은 값, 오른 쪽에는 해당 노드보다 큰 값이 있는 이진 트리. O(logn)으로 탐색 가능
  - 힙(Heap) : 최솟값과 최댓값을 빠르게 찾기 위한 트리. 완전 이진 트리의 한 종류로 O(logn)으로 탐색 가능
    - 최대 힙 : 부모 노드가 자식 노드의 값보다 큰 값인 트리
    - 최대 힙 : 부모 노드가 자식 노드의 값보다 작은 값인 트리
- B 트리 : 여러 자식 노드를 가질 수 있는 다진 탐색 트리
  - 한 노드가 가질 수 있는 자식노드의 개수가 M개일 때, M차 B 트리라고 한다.
  - 이 때 최소 자식 노드의 개수는 ⌈M/2⌉개이다.
  - B 트리의 각 노드에는 하나 이상의 키값이 존재하고, 각 키들은 오름차순으로 저장되어 있다.
  - 각 키가 자식 노드가 가질 수 있는 값의 범위를 나타내는 역할을 하며, 이에 키가 N개인 노드가 기질 수 있는 자식 노드의수는 N+1개이다.
  - 모든 리프 노드의 깊이가 같다.
  - 파일 시스템, 데이터베이스와 같이 대량의 데이터를 기반으로입출력 연산을 수행하는 곳에 활용된다.
    - 입출력 연산은 일반적으로 메모리 접근에 비해 수행속도가 느리다.
    - 운용체제는 블록 단위로 보조기억장치를 읽고 쓴다.
    - 한 블록은 여러 데이터를 포괄하고 있기 때문에 한 노드에 하나의 데이터만 저장하는 이진 탐색 트리에 비해, 한 노드에 블록 단위의 여러 데이터를 저장할 수 있는 B 트리가 보조 기억장치에 대한 연산을 줄일 수 있어 성능 면에서 이득이다.
  - 실제 데이터베이스와 파일시스템에서는 B트리에서 약간 변형된 형태인 B+트리를 사용한다.
    - B+트리에서는 실질적인 데이터가 모두 최하위 리프노드에 존재한다.
    - 최하위 리프노드는 연결리스트의 형태를 띄고 있어 범위 연산에 용이하다.
- 그 밖의 트리
  - 효율적인 문자열 탐색을 위한 트라이, 빠른 구간 연산 세그먼트 트리, 팬윅 트리 등이 있다.

### 그래프

- 정점(데이트)를 간선(링크)로 연결한 형태의 자료구조
  - 트리도 그래프의 일종이지만 사이클을 형성하지 않고, 노드 간에 상하 관계를 갖는다.
- 그래프의 유형
  - 임의의 두 정점 사이를 잇는 경로 유무에 따라 <b>연결 / 비연결 그래프</b>로 구분한다.
  - 간선의 방향 유무에 따라 <b>방향 / 무방향 그래프</b>로 구분한다.
  - 간선에 가중치(비용)가 부여된 그래프를 <b>가중치 그래프</b>로 분류한다.
  - 특정 그래프의 정점과 간선의 일부분으로 이루어진 그래프를 <b>서브 그래프(부분 그래프)</b>라고 한다.
- 그래프 표현 방식
  - 인접 행렬 기반
    - N개의 정점에 대해 NXN 행렬의 형태로 그래프의 연결을 나타낸다.
    - 행, 열의 값은 각각 출발, 도착 정점을 나타낸다.
  - 인접 리스트 기반
    - 특정 정점과 연결된 정점들을 연결 리스트로 표현하는 방법이다.
    - 가중치가 있을 시 하나의 노드에 가중치 정보까지 포함하여 구현할 수 있다.
- 그래프 순회(BFS, DFS)
  - 깊이 우선 탐색(DFS)
    - 그래프에서 더 이상 방문 가능한 정점이 없을 때까지 최대한 깊이 탐색하기를 반복하는 방법
    - 방문 여부를 <b>배열</b>로 관리하고, 방문 중 뒤로 가기가 필요할 때 <b>스택(Stack)</b>을 사용하여 구현한다.
  - 너비 우선 탐색(BFS)
    - 인접한 모든 정점들을 방문하는 방식을 반복하는 방법
    - 방문 여부를 배열로 관리하고, 연결된 정점들을 저장하기위해 <b>큐(Queue)</b>를 사용하여 구현한다.
- 다익스트라 알고리즘(Dijkstra)
  - 최단경로 알고리즘이란 한 정점에서 목적지 정점까지 이르는 가중치의 합이 최소가 되는 경로를 결정하는 알고리즘
  - 다익스트라 알고리즘은 간선의 가중치가 음이 아닌 수라는 가정하에 사용 가능하다.
  - 특정 정점에서 다른 모든 정점까지의 최단 거리를 구해주는 알고리즘
  - 알고리즘 전개 과정
    1. 최단 거리 테이블에서 시작 정점을 제외한 나머지 정점을 충분히 큰 수로 초기화
    2. 정점 방문
    3. 정점과 인접한 정점 탐색
    4. 경로상의 가중치 합과 최단 테이블 상의 값을 비교하여 테이블 갱신
    5. 방문하지 않은 정점 중 최단 거리가 가장 작은 정점 방문
    6. 3~5 반복
