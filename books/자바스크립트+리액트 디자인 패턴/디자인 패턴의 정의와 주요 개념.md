- [Chapter 1. 디자인 패턴 소개](#chapter-1-디자인-패턴-소개)
  - [디자인 패턴이란](#디자인-패턴이란)
  - [디자인 패턴이 유용한 이유](#디자인-패턴이-유용한-이유)
  - [디자인 패턴이 적용된 대표적인 예시](#디자인-패턴이-적용된-대표적인-예시)
- [Chapter 2. 패턴성 검증, 프로토 패턴 그리 세 가지 법칙](#chapter-2-패턴성-검증-프로토-패턴-그리-세-가지-법칙)
  - [프로토 패턴이란](#프로토-패턴이란)
  - [디자인 패턴으로 인정받기 위해서는](#디자인-패턴으로-인정받기-위해서는)
  - [패턴성 검증](#패턴성-검증)
  - [세 가지 법칙](#세-가지-법칙)
- [Chapter 3. 패턴 구조화 및 작성](#chapter-3-패턴-구조화-및-작성)
  - [디자인 패턴의 구조](#디자인-패턴의-구조)
  - [패턴 작성하기](#패턴-작성하기)
- [Chapter 4. 안티 패턴](#chapter-4-안티-패턴)
  - [안티패턴](#안티패턴)
  - [안티패턴을 이해해야 하는 이유](#안티패턴을-이해해야-하는-이유)
  - [자바스크립트 안티 패턴](#자바스크립트-안티-패턴)
- [Chapter 5. 최신 자바스크립트 문법과 기능](#chapter-5-최신-자바스크립트-문법과-기능)
  - [애플리케이션 모듈화의 중요성](#애플리케이션-모듈화의-중요성)
  - [ES 모듈 export, import](#es-모듈-export-import)
  - [모듈 동적으로 가져오기](#모듈-동적으로-가져오기)
  - [모듈 사용시 장점](#모듈-사용시-장점)
  - [클래스](#클래스)
  - [JS 라이브러리, 프레임워크와 클래스](#js-라이브러리-프레임워크와-클래스)
- [Chapter 6. 디자인 패턴의 유형](#chapter-6-디자인-패턴의-유형)
  - [⌜GoF의 디자인 패턴⌟에서의 디자인 패턴 설명](#gof의-디자인-패턴에서의-디자인-패턴-설명)
  - [생성 패턴](#생성-패턴)
  - [구조 패턴](#구조-패턴)
  - [행위 패턴](#행위-패턴)

## Chapter 1. 디자인 패턴 소개

### 디자인 패턴이란

> 소프트웨어 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 탬플릿

### 디자인 패턴이 유용한 이유

- 소프트웨어 개발의 특정 문제를 해결하기 위해 도입된, 검증된 효과적인 접근 방식
- 구조적이고 체계적인 코드 작성으로, 불필요한 코드 중복을 줄이고 유지보수에 적합
- 언어나 애플리케이션 형태에 상관없이, 범용적인 문제에 적용 가능

### 디자인 패턴이 적용된 대표적인 예시

- 상황 : React에서 전역 데이터를 루트 컴포넌트에서, 해당 데이터를 사용하는 하위 컴포넌트로 전달
- 문제 : 해당 데이터를 사용하지 않는 중간 컴포넌트에 props로 데이터가 전달되어 유지보수가 어려워지는 상황 발생(**Props Drilling**)
- 해결책 : **공급자 패턴**을 통해 Props Drilling 문제 해결
  - Context API를 사용해 컨텍스트 공급자(Context Provider)를 통해 상태나 데이터를 여러 컴포넌트에 전달
  - 컨텍스트 소비자(Context Consumber)나 useContext 훅을 사용해 데이터에 접근

<br>

## Chapter 2. 패턴성 검증, 프로토 패턴 그리 세 가지 법칙

### 프로토 패턴이란

> 패턴성 검증을 통과하지 못한 미숙한 패턴

### 디자인 패턴으로 인정받기 위해서는

- 프로토페턴이 패턴성 검증을 거치고, 세 가지 법칙을 충족해야 한다.
- 패턴을 실제로 적용했을 때 나타나는 구조를 시각적으로 표현할 수 있어야 한다.

### 패턴성 검증

- 특정 문제 해결 - 패턴은 **특정 문제를 해결**할 수 있어야 한다.
- 확실한 기능 - 설명에 쓰여진 대로 잘 작동해야 한다.
- 관계 설명 - 패턴의 공식 설명은 코드와의 관계를 나타내는 심층 구조와 메커니즘을 서술해야 한다.

### 세 가지 법칙

좋은 패턴이 되기 위해서는 반복되는 현상에서 지속적으로 사용되어야 한다. 반복성을 입증하기 위해서는 세가지 법칙에 대한 답을 할 수 있어야 한다.

- 목적 적합성 : 좋은 패턴은 어떻게 판단
- 유용성 : 좋은 패턴이라고 할 수 있는 이유
- 적용 가능성 : 넓은 적용범위를 가지고 있어 패턴으로서의 가치가 있는지

<br>

## Chapter 3. 패턴 구조화 및 작성

### 디자인 패턴의 구조

디자인 패턴의 작성자는 패턴의 설계, 구현 방법 및 목적을 설명해야한다. 다음과 같은 관계성을 기반으로, 규칙의 형태로 패턴을 제시한다.

- 컨텍스트(Context) : 패턴이 적용되는 상황
- 집중 목표(System of Forces) : 패턴을 적용할 때 고려해야 하는 목표
- 구성(Configuration) : 제시된 상황과 고려해야 하는 점들을 해결하는 구성

이를 바탕으로 디자인 패턴의 구성 요소를 구성해야 한다.

- 이름 : 패턴의 목적을 표현되는 이름
- 설명 : 패턴이 무엇을 해결할 수 있는지에 대한 설명
- 컨텍스트 개요 : 패턴이 사용자의 요구에 부합하는지에 대한 설명
- 문제 제시 : 패턴을 만든 의도를 알 수 있도록 문제 제시
- 해결 방법 : 이해하기 쉬운 단계와 개념을 통해 문제가 어떻게 해결되는지에 대한 설명

이 이외에도 설계 내용, 구현방법, 시각적 설명, 예제, 관계성, 필수 연계, 용도, 토론 및 의견 등의 구성요소 등이 추가 될 수 있다. 이러한 구성 요소를 고려한 패턴은 계획 및 작성 단계에서 초기 비용이 많이 들지만, 그 투자로 얻을 수 있는 가치가 크다.

### 패턴 작성하기

디자인 패턴 개발 시, 여러 존재하는 디자인 패턴을 참고해 새로운 디자인 패턴을 만들어낼 수 있다. 이 때 다음과 같은 사항을 고려해야 한다.

- 실용성 : 반복적인 문제에 대한 해결책 제시
- 모범 사례 참고 : 패턴의 설계는 모범 사례를 이해해 도출해 낸 원칙에 기반
- 사용자에게 솔직 : 디자인 패턴은 사용자를 위한 것이며, 사용자의 경험을 바꿔서는 안된다.
- 효과적인 예시 : 패턴의 올바른 적용 방법을 보여주는 효과적인 예시 포함

**패턴을 작성한다는 것은 범용성, 구체성, 유용성 사이의 균형을 유지하는 것이다.**

<br>

## Chapter 4. 안티 패턴

### 안티패턴

안티패턴이란 겉으로만 해결책처럼 생긴 패턴으로 두 가지 개념으로 해석할 수 있다

- 문제 상황에 대한 잘못된 해결책
- 문제 상황에서 벗어나 올바른 해결책에 이르는 방법

### 안티패턴을 이해해야 하는 이유

- 나쁜 디자인 패턴을 애플리케이션 개발 과정에 도입하는 경우, 유지보수가 어려워진다.
- 나쁜 디자인 패턴이 안티 패턴이라는 것을 인지하게 된다면 이러한 문제를 사전에 방지할 수 있다.
- 따라서 안티 패턴은 반면교사로 활용하기 위해 문서화해 기록해야 하는 나쁜 디자인 패턴이다.

### 자바스크립트 안티 패턴

자바스크립트는 느슨한 타입 언어이기 때문에 여러 안티 패턴이 발생하게 된다.

- 전역 컨텍스트에서 많은 변수를 정의해 전역 네임스페이스 오염
- 비동기 타이머 함수에 함수가 아닌 문자열을 전달해 내부적으로 eval 실행
- Object 클래스의 프로토타입 수정
- 자바스크립트를 인라인으로 사용
- document.createElement 대신 document.write 사용

<br>

## Chapter 5. 최신 자바스크립트 문법과 기능

### 애플리케이션 모듈화의 중요성

- 모듈화된(잘게 분리된) 애플리케이션은 의존성을 낮추워 유지보수를 용이하게 한다.
- 어느 한 부분의 변경이 다른 부분에 영향을 미치는 지 쉽게 확인이 가능하다.
- ES Module이 ES6에 추가되어 표준으로 자리잡게 되었다.
- 모듈을 통해 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다.

### ES 모듈 export, import

- import 키워드를 통해 모듈을 가져올 수 있다.
  - 기존 변수명과 충돌을 방지하기 위해, 이름을 바꿔서 가져올 수 있다.
  - `import { soccer, baseball } from "sports"` 와 같이 사용할 모듈만을 가져올 수 있다.
  - `import * as Sports from "./sports.mjs"` 와 같이 모듈을 객체로 가져올 수 있다.
- export를 통해 직속 하위 모듈을 내보낼 수 있으며, 이름을 바꿔 내보낼 수 있다.
  - `export { soccer, baseball };` 와 같이 내보내고 싶은 모듈을 객체로 정리해 내보낼 수 있다.
- .mjs는 모듈 파일과 기존 스크립트(js)를 구분하기 위해 쓰이는 모듈 전용 확장자이다.
- `type="module"` 속성을 통해 script 태그에서 모듀을 명시할 수 있다.

### 모듈 동적으로 가져오기

- 정적(Static) 가져오기는 메인 코드를 실행하기 전 모듈을 다운로드하고 실행해야 하므로, 초기 페이지 로드 시 많은 코드를 미리 로드해야 하여, 성능에 문제가 발생할 수 있다.
- 따라서 동적 가져오기(dynamic import)를 통해 필요한 시점에 모듈을 가져옴으로써 위의 문제를 해결할 수 있다.
- 동적 가져오기를 통해 모듈이 사용될 때만 다운로드되고 실행된다.
  - 사용자 상호작용에 반응하거나, 화면에 보이면 실행하기 등에 적용할 수 있다.
- `import(url)` 은 요청된 모듈의 네임스페이스 객체에 대한 프로미스 객체를 반환한다. 또한 동적 가져오기는 await와 함께 사용할 수 있다.

  ```tsx
  form.addEventListener('submit', e => {
  	e.preventDefault();
  	import("/modules/car.js")
  		.then((module) => {
  			module.drive()
  		}
  });

  let car = await import("/modules/car.js")
  ```

### 모듈 사용시 장점

- 한 번만 실행된다.
  - 의존성 트리의 가장 내부에 위치한 모듈이 먼저 실행되고, 여기에 의존하는 모듈이 접근할 수 있다.
- 자동으로 지연 로드된다.
- 독립적으로 실행될 수 있는 코드 조각으로 관리되어 유지보수와 재사용이 쉽다.
- 독립적이 네임스페이스를 제공한다.
- 번들러를 사용해 사용하지 않는 모듈을 자동으로 제거할 수 있다.
  - **트리쉐이킹 : 번들에 추가하기 전 사용하지 않는 코드를 제거**

### 클래스

```tsx
class Person {
  constructor(lastName, firstName, age, assets) {
    this.lastName = lastName;
    this.firstName = firstName;
    this.age = age;
    this.assets = assets;
  }

  getFullName() {
    return this.lastName + this.firstName;
  }

  set addAssets(money) {
    this.assets += money;
  }

  get personAssets() {
    return this.assets;
  }
}

let HP = new Person('Harry', 'Porter', 20, 1000);
// PerSon { lastName: 'Harry', firstName: 'Porter', age: 20, assets: 1000}
console.log(HP);
HP.addAssets = 500;
// PerSon { lastName: 'Harry', firstName: 'Porter', age: 20, assets: 1500}
console.log(HP);
// HarryPorter
console.log(HP.getFullName());
// 1500
console.log(HP.personAssets);
```

- constructor 내부에서 this에 프로퍼티를 정의해, 클래스가 생성한 인스턴스의 프로퍼티를 초기화할 수 있다.
- 접근자 프로퍼티는 자체적으로 값을 갖지 않고, 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 getter 함수와 setter 함수로 구성되어 있다.
- `extends` 키워드를 통해 클래스를 상속할 수 있다.
- ‘#’을 통해 클래스 내부에서만 참조할 수 있는 private 필드를 설정할 수 있다.
- static 키워드를 통해 정적 필드를 정의할 수 있으며, 정적 필드는 클래스를 초기화하지 않고 사용할 수 있다.

### JS 라이브러리, 프레임워크와 클래스

- 최신 JS 라이브러리나 프레임워크는 클레스의 대체제를 도입해 오고 있다. (ex. React Hooks)
- 하지만 웹 컴포넌트(Web Component)와 같이 컴포넌트 개발 과정에서 여전히 클래스는 활용되고 있다.

 <br>

## Chapter 6. 디자인 패턴의 유형

### ⌜GoF의 디자인 패턴⌟에서의 디자인 패턴 설명

- 디자인 패턴은 공통 서계 구조의 핵심 요소를 이름 짓고 추상화하여, 재사용할 수 있는 객체 지향 설계를 만드는데 유용
  - 유용한 클래스와 인스턴스를 통해 역할과 협업, 책임의 분배 실현
- 디자인 패턴은 특정 객체 지향 설계의 문제나 이슈에 초점
  - 어디에 적용될 수 있는 지, 다른 설계 조건에도 부합하는지, 사용함으로써 얻는 장단점과 결과는 무엇인지

디자인 패턴은 어떤 문제를 해결하느냐에 따라 생성 패턴, 구조 패턴, 행위 패턴으로 구분할 수 있다.

### 생성 패턴

- 주어진 상황에 적합한 객체를 생성하는 방법에 중점
- 깩체 생성 방식을 제어하여 문제를 해결하는 것을 목표
- ex) 생성자, 팩토리, 수창, 프로토타입, 싱글톤, 빌더 패턴 등

### 구조 패턴

- 객체의 구성과 각 객체 간의 관계를 인식하는 방법에 주엄
- 시스템의 한 부분이 변경되더라도 다른 부분에 영향이 가지 않도록 하며, 설계 목적에 맞지 않는 부분을 개선하는데 도움
- ex) 데코레이터, 퍼사드, 플라이웨이트, 어댑터, 프록시 패턴

### 행위 패턴

- 시스템 내의 객체 간 커뮤니케이션을 개선하거나 간소화하는 방법에 중점
- 객체 간의 공통적인 커뮤니케이션 패턴을 감지하고, 책임을 분배함으로써 커뮤니케이션의 유연성을 높이고, 객체의 행위를 추상화
- ex) 이터레이터, 중재자, 관찰자, 방문자 패턴
